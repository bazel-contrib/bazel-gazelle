/* Copyright 2018 The Bazel Authors. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resolve

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"sort"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

// ImportSpec describes a library to be imported. Imp is an import string for
// the library. Lang is the language in which the import string appears (this
// should match Resolver.Name).
type ImportSpec struct {
	Lang, Imp string
}

// Resolver is an interface that language extensions can implement to resolve
// dependencies in rules they generate.
type Resolver interface {
	// Name returns the name of the language. This should be a prefix of the
	// kinds of rules generated by the language, e.g., "go" for the Go extension
	// since it generates "go_library" rules.
	Name() string

	// Imports returns a list of ImportSpecs that can be used to import the rule
	// r. This is used to populate RuleIndex.
	//
	// If nil is returned, the rule will not be indexed. If any non-nil slice is
	// returned, including an empty slice, the rule will be indexed.
	Imports(c *config.Config, r *rule.Rule, f *rule.File) []ImportSpec

	// Embeds returns a list of labels of rules that the given rule embeds. If
	// a rule is embedded by another importable rule of the same language, only
	// the embedding rule will be indexed. The embedding rule will inherit
	// the imports of the embedded rule.
	Embeds(r *rule.Rule, from label.Label) []label.Label

	// Resolve translates imported libraries for a given rule into Bazel
	// dependencies. Information about imported libraries is returned for each
	// rule generated by language.GenerateRules in
	// language.GenerateResult.Imports. Resolve generates a "deps" attribute (or
	// the appropriate language-specific equivalent) for each import according to
	// language-specific rules and heuristics.
	Resolve(c *config.Config, ix *RuleIndex, rc *repo.RemoteCache, r *rule.Rule, imports interface{}, from label.Label)
}

// CrossResolver is an interface that language extensions can implement to provide
// custom dependency resolution logic for other languages.
type CrossResolver interface {
	// CrossResolve attempts to resolve an import string to a rule for languages
	// other than the implementing extension. lang is the langauge of the rule
	// with the dependency.
	CrossResolve(c *config.Config, ix *RuleIndex, imp ImportSpec, lang string) []FindResult
}

// RuleIndex is a table of rules in a workspace, indexed by label and by
// import path. Used by Resolver to map import paths to labels.
type RuleIndex struct {
	labelMap  map[label.Label]*ruleRecord
	importMap map[ImportSpec][]label.Label

	// embeddersMap references other rules (of any language) that embed this
	// rule. Embedded rules will be treated as non-indexed, and any FindRulesByImport
	// call that would return the embedded rule will instead return the transitive
	// embeddersMap.
	embeddersMap map[label.Label][]label.Label

	mrslv          func(r *rule.Rule, pkgRel string) Resolver
	crossResolvers []CrossResolver
}

// ruleRecord contains information about a rule relevant to import indexing.
type ruleRecord struct {
	// Package responsible for generating this ruleRecord
	Pkg string `json:"pkg"`

	// Label of this rule
	Label label.Label `json:"label"`

	// ImportedAs is a list of ImportSpecs by which this rule may be imported.
	// Used to build a map from ImportSpecs to ruleRecords.
	ImportedAs []ImportSpec `json:"imported_as"`

	// Embeds is the set of labels (of any language) that this rule directly Embeds,
	// as determined by the Embeds method.
	Embeds []label.Label `json:"embeds,omitempty"`

	// Lang records the language that this import is relevant for.
	// Due to the presence of mapped kinds, it's otherwise
	// impossible to know the underlying builtin rule type for an
	// arbitrary import.
	Lang string `json:"lang"`
}

// NewRuleIndex creates a new index.
//
// kindToResolver is a map from rule kinds (for example, "go_library") to
// Resolvers that support those kinds.
func NewRuleIndex(mrslv func(r *rule.Rule, pkgRel string) Resolver, exts ...interface{}) *RuleIndex {
	var crossResolvers []CrossResolver
	for _, e := range exts {
		if cr, ok := e.(CrossResolver); ok {
			crossResolvers = append(crossResolvers, cr)
		}
	}
	return &RuleIndex{
		labelMap:       make(map[label.Label]*ruleRecord),
		importMap:      make(map[ImportSpec][]label.Label),
		embeddersMap:   make(map[label.Label][]label.Label),
		mrslv:          mrslv,
		crossResolvers: crossResolvers,
	}
}

// AddRule adds a rule r to the index. The rule will only be indexed if there
// is a known resolver for the rule's kind and Resolver.Imports returns a
// non-nil slice.
//
// AddRule may only be called before Finish.
func (ix *RuleIndex) AddRule(c *config.Config, r *rule.Rule, f *rule.File) {
	l := label.New(c.RepoName, f.Pkg, r.Name())
	record := &ruleRecord{
		Pkg:   f.Pkg,
		Label: l,
	}

	rslv := ix.mrslv(r, f.Pkg)
	if rslv == nil {
		return
	}

	record.Lang = rslv.Name()
	if !passesLanguageFilter(c.Langs, record.Lang) {
		return
	}

	record.ImportedAs = rslv.Imports(c, r, f)

	if record.ImportedAs == nil {
		// if Imports returns nil, the rule is not indexed at all
		return
	}

	for _, e := range rslv.Embeds(r, l) {
		embedded := e.Abs(l.Repo, l.Pkg)
		record.Embeds = append(record.Embeds, embedded)
	}

	if _, ok := ix.labelMap[l]; ok {
		log.Printf("multiple rules found with label %s", l)
		return
	}

	ix.indexRule(record)
}

func (ix *RuleIndex) indexRule(record *ruleRecord) {
	ix.labelMap[record.Label] = record
	for _, spec := range record.ImportedAs {
		ix.importMap[spec] = append(ix.importMap[spec], record.Label)
	}

	for _, e := range record.Embeds {
		ix.embeddersMap[e] = append(ix.embeddersMap[e], record.Label)
	}
}

func (ix *RuleIndex) findRuleByLabel(label label.Label, from label.Label) (*ruleRecord, bool) {
	label = label.Abs(from.Repo, from.Pkg)
	r, ok := ix.labelMap[label]
	return r, ok
}

type FindResult struct {
	// Label is the absolute label (including repository and package name) for
	// a matched rule.
	Label label.Label

	// Embeds is the transitive closure of labels for rules that the matched
	// rule embeds. It may contains duplicates and does not include the label
	// for the rule itself.
	Embeds []label.Label
}

// FindRulesByImport attempts to resolve an import string to a rule record.
// imp is the import to resolve (which includes the target language). lang is
// the language of the rule with the dependency (for example, in
// go_proto_library, imp will have ProtoLang and lang will be GoLang).
// from is the rule which is doing the dependency. This is used to check
// vendoring visibility and to check for self-imports.
//
// FindRulesByImport returns a list of rules, since any number of rules may
// provide the same import. Callers may need to resolve ambiguities using
// language-specific heuristics.
//
// DEPRECATED: use FindRulesByImportWithConfig instead
func (ix *RuleIndex) FindRulesByImport(imp ImportSpec, lang string) []FindResult {
	results := []FindResult{}

	allEmbeddingRules := ix.walkEmbeddingGraph(ix.importMap[imp], true)

targets:
	for _, target := range allEmbeddingRules {
		record := ix.labelMap[target]

		if record.Lang != lang {
			continue
		}

		for _, embedder := range ix.embeddersMap[target] {
			// If this rule is embedded by any other rule in this language, it is not directly importable
			if ix.labelMap[embedder].Lang == lang {
				continue targets
			}
		}

		results = append(results, FindResult{
			Label:  target,
			Embeds: ix.walkEmbeddingGraph([]label.Label{target}, false)[1:],
		})
	}

	return results
}

// walkEmbeddingGraph returns the set of rules transitively embedded in the provided rule.
//
// If start is of length 1, the provided starting point will always be the first element in the result.
// If reverse is true, it instead returns the transitive set of labels embedding the provided rule.
func (ix *RuleIndex) walkEmbeddingGraph(start []label.Label, reverse bool) []label.Label {
	var results []label.Label

	// Perform graph traversal, starting with a copy of the starting slice provided.
	// Frontier tracks the set of labels that need to be explored, and explored tracks those
	// that already have.
	// As a future performance improvement, this would benefit from a fast-path to avoid allocation
	// if there's no embedding on any provided labels.
	frontier := append([]label.Label(nil), start...)
	explored := make(map[label.Label]bool)

	for len(frontier) > 0 {
		target := frontier[len(frontier)-1]
		frontier = frontier[:len(frontier)-1]
		if explored[target] {
			continue
		}
		results = append(results, target)
		explored[target] = true

		record := ix.labelMap[target]

		var children []label.Label
		if reverse {
			children = ix.embeddersMap[target]
		} else {
			children = record.Embeds
		}

		frontier = append(frontier, children...)
	}

	return results
}

// FindRulesByImportWithConfig attempts to resolve an import to a rule first by
// checking the rule index, then if no matches are found any registered
// CrossResolve implementations are called.
func (ix *RuleIndex) FindRulesByImportWithConfig(c *config.Config, imp ImportSpec, lang string) []FindResult {
	results := ix.FindRulesByImport(imp, lang)
	if len(results) > 0 {
		return results
	}
	for _, cr := range ix.crossResolvers {
		results = append(results, cr.CrossResolve(c, ix, imp, lang)...)
	}
	return results
}

// IsSelfImport returns true if the result's label matches the given label
// or the result's rule transitively embeds the rule with the given label.
// Self imports cause cyclic dependencies, so the caller may want to omit
// the dependency or report an error.
func (r FindResult) IsSelfImport(from label.Label) bool {
	if from.Equal(r.Label) {
		return true
	}
	for _, e := range r.Embeds {
		if from.Equal(e) {
			return true
		}
	}
	return false
}

// passesLanguageFilter returns true if the filter is empty (disabled) or if the
// given language name appears in it.
func passesLanguageFilter(langFilter []string, langName string) bool {
	if len(langFilter) == 0 {
		return true
	}
	for _, l := range langFilter {
		if l == langName {
			return true
		}
	}
	return false
}

const indexFileVersion = 1

type indexFileData struct {
	Version int           `json:"version"`
	Data    []*ruleRecord `json:"data"`
}

// WriteToFile saves all data in the index to a JSON file at the path provided.
//
// This file is not expected to have a stable format between Gazelle versions, but
// a best-effort attempt is made to keep it sorted so it _should_ remain stable
// between runs.
func (ix *RuleIndex) WriteToFile(path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	contents := indexFileData{
		Version: indexFileVersion,
	}
	for _, v := range ix.labelMap {
		contents.Data = append(contents.Data, v)
	}

	sort.Slice(contents.Data, func(i, j int) bool {
		return contents.Data[i].Label.String() < contents.Data[j].Label.String()
	})

	encoder := json.NewEncoder(f)
	encoder.SetIndent("", "    ")

	err = encoder.Encode(contents.Data)
	if err != nil {
		return err
	}

	return nil
}

// ReadFromFile reads back in the index data saved by WriteToFile.
//
// Any data in the index which was originally obtained by scanning a package
// which matches the provided exclude function will not be read in, and will instead be dropped.
// For Gazelle to produce the same output as it would with a full re-index, it is important
// that any packages that have changed since the run that produced the index file are explicitly
// passed to the new Gazelle invocation so they are excluded here and scanned again.
func (ix *RuleIndex) ReadFromFile(path string, exclude func(string) bool) error {
	f, err := os.Open(path)
	if err != nil {
		return err
	}
	defer f.Close()

	var contents indexFileData
	err = json.NewDecoder(f).Decode(&contents)
	if err != nil {
		return err
	}

	if contents.Version != indexFileVersion {
		return fmt.Errorf("version mismatch, expected %d got %d", contents.Version, indexFileVersion)
	}

	for _, v := range contents.Data {
		if exclude(v.Pkg) {
			continue
		}
		ix.indexRule(v)
	}

	return nil
}
